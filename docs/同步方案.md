# 同步原理

从存储结构可知，整个白板View的显示完全遵从上述Model的内容进行显示渲染，故上述Model是白板View的ViewModel。

而Model内容实际上可作为一个巨大的HashMap进行存储，而多人协同需要完成的工作就是同步各个节点中的HashMap的状态一致性。

故状态同步方案可有以下几种：

### 完整同步

一个暴力的解决方案就是每次同步分发主节点中的整个HashMap的数据到各个子节点中，但是这么做会出现以下问题：

1. 显而易见的就是序列化反序列化的时间和空间开销剧增

2. 前端ui控件可能针对某些数据model有构建缓存，若重新反序列化整个model，则可能导致大量的缓存失效，导致频繁重建整个ui会相当卡顿。

3. 每次反序列化model，刷新ui伴随着大量的对象的创建与销毁，对gc的压力巨大。

4. 当数据量大时对网络传输的压力也越来越严重。
   
   ### 增量同步

稍微优化的方案就是每次只向各个子节点传递主节点的增量更新的内容，获取增量更新的内容使用的是diff算法，可在算法讲解中查看更加详细的内容，该算法实现在/modules/json_diff_pather中

增量同步可能会出现一下问题：

1. 新加入的子节点无法获取到之前已同步的数据

2. 数据一致性问题，某些情况可能导致数据不一致

3. 若实现双向同步，则还需要解决同步冲突的问题。
   
   ### 先完整后增量同步

SIT-board综合了完整同步与增量同步的方法，在子节点加入分布式网络时先进行完整同步，后续进行增量同步，并且该同步实现代码在/modules/json_model_sync下，可作为一个独立的dart第三方库进行分发使用。
